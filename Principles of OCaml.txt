OCaml Principles:

Primary Characteristics:
	- Expression evaluation - no assignment statements
		(Purely function core of the language)
		(Primary means of computation)
		
		- Expressions are what appear on the RHS of assignment statements
		- OCaml has no while loops, for loops, etc. To fix these in a functional
		programming language, we use Recusion & higher-order functions
		
		Integer Operators:
			+ (add)
			- (subtract)
			* (multiply)
			/ (divide)
		
		Floating Point Operators:
			+. (add)
			-. (subtract)
			*. (multiply)
			/. (divide)
			
	- Strong, static type system
		(Types are inferred, if not written explicitly)
		(x = 2 would be inferred as an integer, whilst
		 x = 2.0 would be inferred as a float)
		 
		 OCaml Types:
		 int, float, bool, string, char
			Errors will be reported for expressions like 1 + "Hello"
					This is because the operator `+` represents integer addition,
					since "Hello" is not an integer, this exception will be caught
				- Other errors like divide by zero are caught as well
				
		Modules organize code into useful components
			String & Char modules contain functions you might expect
			Access those functions like : https://gyazo.com/d565469cb9f795b8768ed46da70e5556
			
		Name Binding: let-declarations & let-expressions
			
			let-declaration - appears at the top level of a file
				(let)
			ex:	
			let var = expr
				(e.g. let x = 7 ;;)
			
			let-expression - appears anywhere an expression can appear
				(let in)
			ex:
			let var = expr in expr
				(e.g. let y = 8 in y * y ;;)
				
				- OCaml Infers identifiers, but we can provide them explicitly
				- We can nest let-expressions
			
	- Support for Structured Data
		(Lists, tuples, records, inductive types - algebraic data types)
	- Pattern Matching of data
		Like a switch keyword in C/C++/Java, OCaml uses match keyword
		
		
utop is the "toplevel" REPL (read-evaluate-print-loop) for OCaml

Using files from toplevel:
	#use "my_file.ml" ;;
	
	(* This opens the file in OCaml, thus the functions can be used *)
	
	#quit ;;  - quits OCaml toplevel
	
Functions, over simple data:

	let name parameters = expr
		(e.g. let inc x = x + 1)
			The name of the function: inc
			Function's parameters: x
			expression: x + 1
					
					We can infer from this example function that it will be int -> int
					Since the operator of the expression adds integers!
					
					val inc : int -> int = <fun>
					
	ex 2:
	
	let add x y = x + y ;;
	val add : int -> int -> int = <fun>
	
		This is short for:
		let add = fun x -> (fun y -> x + y) ;;
		val add : int -> int -> int = <fun>
			
			Note: The function type operator -> is right associative
				int -> (int -> int) = int -> int -> int 
				
		Using add, defined on line 87, we can make a curried function increment:
		let increment = add 1 ;;
		val inc : int -> int = <fun>
		
			Essentially, increment is the same as writing add 1
			Which, add 1 requires one more parameter
					Ex: we would call something like: add 1 2 ;; to get 3
				Now, we can write: increment 2;; to get 3

Recursive Functions

"let rec" expressions: use let rec to define a recursive function

ex: fibonacci sequence:
	let rec fib = x
    if x = 0 then 0 else
        if x < 3 then 1 else fib (x-1) + fib (x-2)